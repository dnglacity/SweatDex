[
  {
    "consolidated_blueprint": "{\n    \"views\": [\n        {\n            \"view_name\": \"v_stuck_registrations\",\n            \"definition\": \" SELECT au.id AS auth_user_id,\\n    au.email,\\n    au.created_at AS auth_created_at,\\n    au.email_confirmed_at\\n   FROM auth.users au\\n     LEFT JOIN users pu ON pu.user_id = au.id\\n  WHERE au.email_confirmed_at IS NULL AND pu.id IS NULL;\"\n        }\n    ],\n    \"indexes\": [\n        {\n            \"is_unique\": false,\n            \"definition\": \"CREATE INDEX idx_gr_team_id ON public.game_rosters USING btree (team_id)\",\n            \"index_name\": \"idx_gr_team_id\",\n            \"is_primary\": false,\n            \"table_name\": \"game_rosters\"\n        },\n        {\n            \"is_unique\": true,\n            \"definition\": \"CREATE UNIQUE INDEX guardian_links_player_id_user_id_key ON public.guardian_links USING btree (player_id, user_id)\",\n            \"index_name\": \"guardian_links_player_id_user_id_key\",\n            \"is_primary\": false,\n            \"table_name\": \"guardian_links\"\n        },\n        {\n            \"is_unique\": false,\n            \"definition\": \"CREATE INDEX idx_guardian_links_player ON public.guardian_links USING btree (player_id)\",\n            \"index_name\": \"idx_guardian_links_player\",\n            \"is_primary\": false,\n            \"table_name\": \"guardian_links\"\n        },\n        {\n            \"is_unique\": false,\n            \"definition\": \"CREATE INDEX idx_guardian_links_player_id ON public.guardian_links USING btree (player_id)\",\n            \"index_name\": \"idx_guardian_links_player_id\",\n            \"is_primary\": false,\n            \"table_name\": \"guardian_links\"\n        },\n        {\n            \"is_unique\": false,\n            \"definition\": \"CREATE INDEX idx_guardian_links_user ON public.guardian_links USING btree (user_id)\",\n            \"index_name\": \"idx_guardian_links_user\",\n            \"is_primary\": false,\n            \"table_name\": \"guardian_links\"\n        },\n        {\n            \"is_unique\": false,\n            \"definition\": \"CREATE INDEX idx_guardian_links_user_id ON public.guardian_links USING btree (user_id)\",\n            \"index_name\": \"idx_guardian_links_user_id\",\n            \"is_primary\": false,\n            \"table_name\": \"guardian_links\"\n        },\n        {\n            \"is_unique\": false,\n            \"definition\": \"CREATE INDEX idx_players_athlete_email ON public.players USING btree (athlete_email) WHERE (athlete_email IS NOT NULL)\",\n            \"index_name\": \"idx_players_athlete_email\",\n            \"is_primary\": false,\n            \"table_name\": \"players\"\n        },\n        {\n            \"is_unique\": false,\n            \"definition\": \"CREATE INDEX idx_players_guardian_email ON public.players USING btree (guardian_email) WHERE (guardian_email IS NOT NULL)\",\n            \"index_name\": \"idx_players_guardian_email\",\n            \"is_primary\": false,\n            \"table_name\": \"players\"\n        },\n        {\n            \"is_unique\": false,\n            \"definition\": \"CREATE INDEX idx_players_team_id ON public.players USING btree (team_id)\",\n            \"index_name\": \"idx_players_team_id\",\n            \"is_primary\": false,\n            \"table_name\": \"players\"\n        },\n        {\n            \"is_unique\": false,\n            \"definition\": \"CREATE INDEX idx_players_user_id ON public.players USING btree (user_id) WHERE (user_id IS NOT NULL)\",\n            \"index_name\": \"idx_players_user_id\",\n            \"is_primary\": false,\n            \"table_name\": \"players\"\n        },\n        {\n            \"is_unique\": true,\n            \"definition\": \"CREATE UNIQUE INDEX sports_name_key ON public.sports USING btree (name)\",\n            \"index_name\": \"sports_name_key\",\n            \"is_primary\": false,\n            \"table_name\": \"sports\"\n        },\n        {\n            \"is_unique\": true,\n            \"definition\": \"CREATE UNIQUE INDEX team_invites_one_active ON public.team_invites USING btree (team_id) WHERE (is_active = true)\",\n            \"index_name\": \"team_invites_one_active\",\n            \"is_primary\": false,\n            \"table_name\": \"team_invites\"\n        },\n        {\n            \"is_unique\": false,\n            \"definition\": \"CREATE INDEX idx_tm_team_user_role ON public.team_members USING btree (team_id, user_id, role)\",\n            \"index_name\": \"idx_tm_team_user_role\",\n            \"is_primary\": false,\n            \"table_name\": \"team_members\"\n        },\n        {\n            \"is_unique\": true,\n            \"definition\": \"CREATE UNIQUE INDEX team_members_team_id_user_id_key ON public.team_members USING btree (team_id, user_id)\",\n            \"index_name\": \"team_members_team_id_user_id_key\",\n            \"is_primary\": false,\n            \"table_name\": \"team_members\"\n        },\n        {\n            \"is_unique\": true,\n            \"definition\": \"CREATE UNIQUE INDEX team_members_team_user_unique ON public.team_members USING btree (team_id, user_id)\",\n            \"index_name\": \"team_members_team_user_unique\",\n            \"is_primary\": false,\n            \"table_name\": \"team_members\"\n        },\n        {\n            \"is_unique\": false,\n            \"definition\": \"CREATE INDEX idx_teams_created_by ON public.teams USING btree (created_by)\",\n            \"index_name\": \"idx_teams_created_by\",\n            \"is_primary\": false,\n            \"table_name\": \"teams\"\n        },\n        {\n            \"is_unique\": false,\n            \"definition\": \"CREATE INDEX idx_users_email ON public.users USING btree (lower(email))\",\n            \"index_name\": \"idx_users_email\",\n            \"is_primary\": false,\n            \"table_name\": \"users\"\n        },\n        {\n            \"is_unique\": false,\n            \"definition\": \"CREATE INDEX idx_users_user_id ON public.users USING btree (user_id)\",\n            \"index_name\": \"idx_users_user_id\",\n            \"is_primary\": false,\n            \"table_name\": \"users\"\n        },\n        {\n            \"is_unique\": true,\n            \"definition\": \"CREATE UNIQUE INDEX users_email_unique ON public.users USING btree (email)\",\n            \"index_name\": \"users_email_unique\",\n            \"is_primary\": false,\n            \"table_name\": \"users\"\n        },\n        {\n            \"is_unique\": true,\n            \"definition\": \"CREATE UNIQUE INDEX users_user_id_key ON public.users USING btree (user_id)\",\n            \"index_name\": \"users_user_id_key\",\n            \"is_primary\": false,\n            \"table_name\": \"users\"\n        }\n    ],\n    \"policies\": [\n        {\n            \"roles\": \"{authenticated}\",\n            \"operation\": \"DELETE\",\n            \"tablename\": \"game_rosters\",\n            \"policyname\": \"game_rosters_delete_creator_owner\",\n            \"schemaname\": \"public\",\n            \"check_expression\": null,\n            \"using_expression\": \"((created_by = private.get_my_user_id()) OR is_team_owner(team_id))\"\n        },\n        {\n            \"roles\": \"{authenticated}\",\n            \"operation\": \"INSERT\",\n            \"tablename\": \"game_rosters\",\n            \"policyname\": \"game_rosters_insert_member\",\n            \"schemaname\": \"public\",\n            \"check_expression\": \"is_team_member(team_id)\",\n            \"using_expression\": null\n        },\n        {\n            \"roles\": \"{authenticated}\",\n            \"operation\": \"SELECT\",\n            \"tablename\": \"game_rosters\",\n            \"policyname\": \"game_rosters_select_member\",\n            \"schemaname\": \"public\",\n            \"check_expression\": null,\n            \"using_expression\": \"(team_id IN ( SELECT private.get_my_team_ids() AS get_my_team_ids))\"\n        },\n        {\n            \"roles\": \"{authenticated}\",\n            \"operation\": \"UPDATE\",\n            \"tablename\": \"game_rosters\",\n            \"policyname\": \"game_rosters_update_member\",\n            \"schemaname\": \"public\",\n            \"check_expression\": null,\n            \"using_expression\": \"(team_id IN ( SELECT private.get_my_team_ids() AS get_my_team_ids))\"\n        },\n        {\n            \"roles\": \"{authenticated}\",\n            \"operation\": \"DELETE\",\n            \"tablename\": \"guardian_links\",\n            \"policyname\": \"guardian_links_delete_own\",\n            \"schemaname\": \"public\",\n            \"check_expression\": null,\n            \"using_expression\": \"(user_id = private.get_my_user_id())\"\n        },\n        {\n            \"roles\": \"{authenticated}\",\n            \"operation\": \"INSERT\",\n            \"tablename\": \"guardian_links\",\n            \"policyname\": \"guardian_links_insert_authenticated\",\n            \"schemaname\": \"public\",\n            \"check_expression\": \"(user_id = ( SELECT private.get_my_user_id() AS get_my_user_id))\",\n            \"using_expression\": null\n        },\n        {\n            \"roles\": \"{authenticated}\",\n            \"operation\": \"SELECT\",\n            \"tablename\": \"guardian_links\",\n            \"policyname\": \"guardian_links_select_own\",\n            \"schemaname\": \"public\",\n            \"check_expression\": null,\n            \"using_expression\": \"((user_id = private.get_my_user_id()) OR (player_id IN ( SELECT players.id\\n   FROM players\\n  WHERE (players.user_id = private.get_my_user_id()))))\"\n        },\n        {\n            \"roles\": \"{authenticated}\",\n            \"operation\": \"UPDATE\",\n            \"tablename\": \"guardian_links\",\n            \"policyname\": \"guardian_links_update_own\",\n            \"schemaname\": \"public\",\n            \"check_expression\": \"(user_id = ( SELECT private.get_my_user_id() AS get_my_user_id))\",\n            \"using_expression\": \"(user_id = ( SELECT private.get_my_user_id() AS get_my_user_id))\"\n        },\n        {\n            \"roles\": \"{authenticated}\",\n            \"operation\": \"DELETE\",\n            \"tablename\": \"players\",\n            \"policyname\": \"players_delete_coach\",\n            \"schemaname\": \"public\",\n            \"check_expression\": null,\n            \"using_expression\": \"(EXISTS ( SELECT 1\\n   FROM team_members tm\\n  WHERE ((tm.team_id = players.team_id) AND (tm.user_id = private.get_my_user_id()) AND (tm.role = ANY (ARRAY['coach'::text, 'owner'::text, 'team_manager'::text])))))\"\n        },\n        {\n            \"roles\": \"{authenticated}\",\n            \"operation\": \"INSERT\",\n            \"tablename\": \"players\",\n            \"policyname\": \"players_insert_coach\",\n            \"schemaname\": \"public\",\n            \"check_expression\": \"is_team_member(team_id)\",\n            \"using_expression\": null\n        },\n        {\n            \"roles\": \"{authenticated}\",\n            \"operation\": \"SELECT\",\n            \"tablename\": \"players\",\n            \"policyname\": \"players_select_member\",\n            \"schemaname\": \"public\",\n            \"check_expression\": null,\n            \"using_expression\": \"(team_id IN ( SELECT private.get_my_team_ids() AS get_my_team_ids))\"\n        },\n        {\n            \"roles\": \"{authenticated}\",\n            \"operation\": \"UPDATE\",\n            \"tablename\": \"players\",\n            \"policyname\": \"players_update_member\",\n            \"schemaname\": \"public\",\n            \"check_expression\": null,\n            \"using_expression\": \"(team_id IN ( SELECT private.get_my_team_ids() AS get_my_team_ids))\"\n        },\n        {\n            \"roles\": \"{authenticated}\",\n            \"operation\": \"SELECT\",\n            \"tablename\": \"sports\",\n            \"policyname\": \"sports_select_authenticated\",\n            \"schemaname\": \"public\",\n            \"check_expression\": null,\n            \"using_expression\": \"true\"\n        },\n        {\n            \"roles\": \"{public}\",\n            \"operation\": \"SELECT\",\n            \"tablename\": \"team_invites\",\n            \"policyname\": \"Managers can view team invites\",\n            \"schemaname\": \"public\",\n            \"check_expression\": null,\n            \"using_expression\": \"(EXISTS ( SELECT 1\\n   FROM (team_members tm\\n     JOIN users u ON ((u.id = tm.user_id)))\\n  WHERE ((tm.team_id = team_invites.team_id) AND (u.user_id = auth.uid()) AND (tm.role = ANY (ARRAY['owner'::text, 'coach'::text, 'team_manager'::text])))))\"\n        },\n        {\n            \"roles\": \"{authenticated}\",\n            \"operation\": \"DELETE\",\n            \"tablename\": \"team_members\",\n            \"policyname\": \"team_members_delete_self_owner\",\n            \"schemaname\": \"public\",\n            \"check_expression\": null,\n            \"using_expression\": \"((user_id = ( SELECT private.get_my_user_id() AS get_my_user_id)) OR ( SELECT is_team_owner(team_members.team_id) AS is_team_owner))\"\n        },\n        {\n            \"roles\": \"{authenticated}\",\n            \"operation\": \"SELECT\",\n            \"tablename\": \"team_members\",\n            \"policyname\": \"team_members_select_own_teams\",\n            \"schemaname\": \"public\",\n            \"check_expression\": null,\n            \"using_expression\": \"(team_id IN ( SELECT private.get_my_team_ids() AS get_my_team_ids))\"\n        },\n        {\n            \"roles\": \"{authenticated}\",\n            \"operation\": \"UPDATE\",\n            \"tablename\": \"team_members\",\n            \"policyname\": \"team_members_update_owner\",\n            \"schemaname\": \"public\",\n            \"check_expression\": null,\n            \"using_expression\": \"((user_id = ( SELECT private.get_my_user_id() AS get_my_user_id)) OR ( SELECT is_team_owner(team_members.team_id) AS is_team_owner))\"\n        },\n        {\n            \"roles\": \"{authenticated}\",\n            \"operation\": \"DELETE\",\n            \"tablename\": \"teams\",\n            \"policyname\": \"teams_delete_owner\",\n            \"schemaname\": \"public\",\n            \"check_expression\": null,\n            \"using_expression\": \"is_team_owner(id)\"\n        },\n        {\n            \"roles\": \"{authenticated}\",\n            \"operation\": \"SELECT\",\n            \"tablename\": \"teams\",\n            \"policyname\": \"teams_select_member\",\n            \"schemaname\": \"public\",\n            \"check_expression\": null,\n            \"using_expression\": \"(id IN ( SELECT private.get_my_team_ids() AS get_my_team_ids))\"\n        },\n        {\n            \"roles\": \"{authenticated}\",\n            \"operation\": \"UPDATE\",\n            \"tablename\": \"teams\",\n            \"policyname\": \"teams_update_owner\",\n            \"schemaname\": \"public\",\n            \"check_expression\": \"is_team_owner(id)\",\n            \"using_expression\": \"is_team_owner(id)\"\n        },\n        {\n            \"roles\": \"{authenticated}\",\n            \"operation\": \"DELETE\",\n            \"tablename\": \"users\",\n            \"policyname\": \"users_delete_own\",\n            \"schemaname\": \"public\",\n            \"check_expression\": null,\n            \"using_expression\": \"(user_id = ( SELECT auth.uid() AS uid))\"\n        },\n        {\n            \"roles\": \"{authenticated}\",\n            \"operation\": \"INSERT\",\n            \"tablename\": \"users\",\n            \"policyname\": \"users_insert_own\",\n            \"schemaname\": \"public\",\n            \"check_expression\": \"(user_id = ( SELECT auth.uid() AS uid))\",\n            \"using_expression\": null\n        },\n        {\n            \"roles\": \"{authenticated}\",\n            \"operation\": \"SELECT\",\n            \"tablename\": \"users\",\n            \"policyname\": \"users_select_own\",\n            \"schemaname\": \"public\",\n            \"check_expression\": null,\n            \"using_expression\": \"((user_id = auth.uid()) OR (id IN ( SELECT tm2.user_id\\n   FROM (team_members tm1\\n     JOIN team_members tm2 USING (team_id))\\n  WHERE (tm1.user_id = private.get_my_user_id()))))\"\n        },\n        {\n            \"roles\": \"{authenticated}\",\n            \"operation\": \"UPDATE\",\n            \"tablename\": \"users\",\n            \"policyname\": \"users_update_own\",\n            \"schemaname\": \"public\",\n            \"check_expression\": \"(user_id = ( SELECT auth.uid() AS uid))\",\n            \"using_expression\": \"(user_id = ( SELECT auth.uid() AS uid))\"\n        }\n    ],\n    \"triggers\": [\n        {\n            \"event\": \"UPDATE\",\n            \"timing\": \"AFTER\",\n            \"condition\": null,\n            \"table_name\": \"players\",\n            \"orientation\": \"ROW\",\n            \"trigger_name\": \"trg_sync_player_membership_on_link\",\n            \"function_name\": \"fn_sync_player_membership_on_link\",\n            \"function_schema\": \"public\",\n            \"function_definition\": \"CREATE OR REPLACE FUNCTION public.fn_sync_player_membership_on_link()\\n RETURNS trigger\\n LANGUAGE plpgsql\\n SECURITY DEFINER\\n SET search_path TO 'public'\\nAS $function$\\r\\nBEGIN\\r\\n  -- Only act when user_id transitions from NULL to a non-NULL value.\\r\\n  -- This prevents the trigger from firing on routine player UPDATE calls\\r\\n  -- (e.g., status changes, name edits) that don't touch user_id.\\r\\n  IF OLD.user_id IS NULL AND NEW.user_id IS NOT NULL THEN\\r\\n\\r\\n    -- Upsert a team_members row so the newly-linked user can see the team.\\r\\n    --\\r\\n    -- ON CONFLICT: if a row already exists for this (team_id, user_id) pair\\r\\n    -- (e.g., manually added as a coach before being linked as a player),\\r\\n    -- preserve the existing role rather than downgrading it to 'player'.\\r\\n    -- Only update player_id if it is not yet set.\\r\\n    INSERT INTO public.team_members (team_id, user_id, role, player_id)\\r\\n    VALUES (NEW.team_id, NEW.user_id, 'player', NEW.id)\\r\\n    ON CONFLICT (team_id, user_id)\\r\\n    DO UPDATE SET\\r\\n      player_id = EXCLUDED.player_id\\r\\n      -- NOTE: role is intentionally NOT updated here so that a user who is\\r\\n      -- already a 'coach' or 'owner' on the team does not get demoted to\\r\\n      -- 'player' just because a player row was linked to their account.\\r\\n      -- If the existing role needs changing, use the \\\"Change Role\\\" dialog\\r\\n      -- in ManageMembersScreen.\\r\\n    ;\\r\\n\\r\\n  END IF;\\r\\n\\r\\n  -- Return NEW so the original UPDATE proceeds normally.\\r\\n  RETURN NEW;\\r\\nEND;\\r\\n$function$\\n\"\n        },\n        {\n            \"event\": \"INSERT\",\n            \"timing\": \"AFTER\",\n            \"condition\": null,\n            \"table_name\": \"users\",\n            \"orientation\": \"ROW\",\n            \"trigger_name\": \"trg_auto_link_players_on_signup\",\n            \"function_name\": \"fn_auto_link_players_on_signup\",\n            \"function_schema\": \"public\",\n            \"function_definition\": \"CREATE OR REPLACE FUNCTION public.fn_auto_link_players_on_signup()\\n RETURNS trigger\\n LANGUAGE plpgsql\\n SECURITY DEFINER\\n SET search_path TO 'public'\\nAS $function$\\r\\nBEGIN\\r\\n  -- For every player record whose athlete_email matches the new user's email\\r\\n  -- and that isn't linked yet, set user_id and upsert a team_members row.\\r\\n  UPDATE public.players\\r\\n  SET user_id = NEW.id\\r\\n  WHERE LOWER(TRIM(athlete_email)) = LOWER(TRIM(NEW.email))\\r\\n    AND user_id IS NULL;\\r\\n\\r\\n  -- The existing trigger fn_sync_player_membership_on_link fires on each\\r\\n  -- players.user_id update and upserts the team_members row automatically,\\r\\n  -- so no explicit team_members INSERT is needed here.\\r\\n\\r\\n  RETURN NEW;\\r\\nEND;\\r\\n$function$\\n\"\n        }\n    ],\n    \"blueprint\": [\n        {\n            \"data_type\": \"uuid\",\n            \"table_name\": \"game_rosters\",\n            \"column_name\": \"id\",\n            \"is_nullable\": \"NO\",\n            \"column_default\": \"uuid_generate_v4()\"\n        },\n        {\n            \"data_type\": \"uuid\",\n            \"table_name\": \"game_rosters\",\n            \"column_name\": \"team_id\",\n            \"is_nullable\": \"NO\",\n            \"column_default\": null\n        },\n        {\n            \"data_type\": \"text\",\n            \"table_name\": \"game_rosters\",\n            \"column_name\": \"title\",\n            \"is_nullable\": \"NO\",\n            \"column_default\": null\n        },\n        {\n            \"data_type\": \"text\",\n            \"table_name\": \"game_rosters\",\n            \"column_name\": \"game_date\",\n            \"is_nullable\": \"YES\",\n            \"column_default\": null\n        },\n        {\n            \"data_type\": \"integer\",\n            \"table_name\": \"game_rosters\",\n            \"column_name\": \"starter_slots\",\n            \"is_nullable\": \"NO\",\n            \"column_default\": \"5\"\n        },\n        {\n            \"data_type\": \"jsonb\",\n            \"table_name\": \"game_rosters\",\n            \"column_name\": \"starters\",\n            \"is_nullable\": \"NO\",\n            \"column_default\": \"'[]'::jsonb\"\n        },\n        {\n            \"data_type\": \"jsonb\",\n            \"table_name\": \"game_rosters\",\n            \"column_name\": \"substitutes\",\n            \"is_nullable\": \"NO\",\n            \"column_default\": \"'[]'::jsonb\"\n        },\n        {\n            \"data_type\": \"uuid\",\n            \"table_name\": \"game_rosters\",\n            \"column_name\": \"created_by\",\n            \"is_nullable\": \"YES\",\n            \"column_default\": null\n        },\n        {\n            \"data_type\": \"timestamp with time zone\",\n            \"table_name\": \"game_rosters\",\n            \"column_name\": \"created_at\",\n            \"is_nullable\": \"NO\",\n            \"column_default\": \"now()\"\n        },\n        {\n            \"data_type\": \"uuid\",\n            \"table_name\": \"guardian_links\",\n            \"column_name\": \"id\",\n            \"is_nullable\": \"NO\",\n            \"column_default\": \"gen_random_uuid()\"\n        },\n        {\n            \"data_type\": \"uuid\",\n            \"table_name\": \"guardian_links\",\n            \"column_name\": \"player_id\",\n            \"is_nullable\": \"NO\",\n            \"column_default\": null\n        },\n        {\n            \"data_type\": \"uuid\",\n            \"table_name\": \"guardian_links\",\n            \"column_name\": \"user_id\",\n            \"is_nullable\": \"NO\",\n            \"column_default\": null\n        },\n        {\n            \"data_type\": \"boolean\",\n            \"table_name\": \"guardian_links\",\n            \"column_name\": \"confirmed\",\n            \"is_nullable\": \"NO\",\n            \"column_default\": \"false\"\n        },\n        {\n            \"data_type\": \"timestamp with time zone\",\n            \"table_name\": \"guardian_links\",\n            \"column_name\": \"created_at\",\n            \"is_nullable\": \"NO\",\n            \"column_default\": \"now()\"\n        },\n        {\n            \"data_type\": \"uuid\",\n            \"table_name\": \"players\",\n            \"column_name\": \"id\",\n            \"is_nullable\": \"NO\",\n            \"column_default\": \"uuid_generate_v4()\"\n        },\n        {\n            \"data_type\": \"uuid\",\n            \"table_name\": \"players\",\n            \"column_name\": \"team_id\",\n            \"is_nullable\": \"NO\",\n            \"column_default\": null\n        },\n        {\n            \"data_type\": \"uuid\",\n            \"table_name\": \"players\",\n            \"column_name\": \"user_id\",\n            \"is_nullable\": \"YES\",\n            \"column_default\": null\n        },\n        {\n            \"data_type\": \"text\",\n            \"table_name\": \"players\",\n            \"column_name\": \"athlete_id\",\n            \"is_nullable\": \"YES\",\n            \"column_default\": null\n        },\n        {\n            \"data_type\": \"text\",\n            \"table_name\": \"players\",\n            \"column_name\": \"athlete_email\",\n            \"is_nullable\": \"YES\",\n            \"column_default\": null\n        },\n        {\n            \"data_type\": \"text\",\n            \"table_name\": \"players\",\n            \"column_name\": \"guardian_email\",\n            \"is_nullable\": \"YES\",\n            \"column_default\": null\n        },\n        {\n            \"data_type\": \"smallint\",\n            \"table_name\": \"players\",\n            \"column_name\": \"grade\",\n            \"is_nullable\": \"YES\",\n            \"column_default\": null\n        },\n        {\n            \"data_type\": \"timestamp with time zone\",\n            \"table_name\": \"players\",\n            \"column_name\": \"grade_updated_at\",\n            \"is_nullable\": \"YES\",\n            \"column_default\": null\n        },\n        {\n            \"data_type\": \"text\",\n            \"table_name\": \"players\",\n            \"column_name\": \"jersey_number\",\n            \"is_nullable\": \"YES\",\n            \"column_default\": null\n        },\n        {\n            \"data_type\": \"text\",\n            \"table_name\": \"players\",\n            \"column_name\": \"nickname\",\n            \"is_nullable\": \"YES\",\n            \"column_default\": null\n        },\n        {\n            \"data_type\": \"text\",\n            \"table_name\": \"players\",\n            \"column_name\": \"position\",\n            \"is_nullable\": \"YES\",\n            \"column_default\": null\n        },\n        {\n            \"data_type\": \"text\",\n            \"table_name\": \"players\",\n            \"column_name\": \"status\",\n            \"is_nullable\": \"NO\",\n            \"column_default\": \"'present'::text\"\n        },\n        {\n            \"data_type\": \"timestamp with time zone\",\n            \"table_name\": \"players\",\n            \"column_name\": \"created_at\",\n            \"is_nullable\": \"NO\",\n            \"column_default\": \"now()\"\n        },\n        {\n            \"data_type\": \"text\",\n            \"table_name\": \"players\",\n            \"column_name\": \"first_name\",\n            \"is_nullable\": \"NO\",\n            \"column_default\": \"''::text\"\n        },\n        {\n            \"data_type\": \"text\",\n            \"table_name\": \"players\",\n            \"column_name\": \"last_name\",\n            \"is_nullable\": \"NO\",\n            \"column_default\": \"''::text\"\n        },\n        {\n            \"data_type\": \"text\",\n            \"table_name\": \"players\",\n            \"column_name\": \"name\",\n            \"is_nullable\": \"YES\",\n            \"column_default\": null\n        },\n        {\n            \"data_type\": \"uuid\",\n            \"table_name\": \"sports\",\n            \"column_name\": \"id\",\n            \"is_nullable\": \"NO\",\n            \"column_default\": \"uuid_generate_v4()\"\n        },\n        {\n            \"data_type\": \"text\",\n            \"table_name\": \"sports\",\n            \"column_name\": \"name\",\n            \"is_nullable\": \"NO\",\n            \"column_default\": null\n        },\n        {\n            \"data_type\": \"text\",\n            \"table_name\": \"sports\",\n            \"column_name\": \"category\",\n            \"is_nullable\": \"NO\",\n            \"column_default\": \"'Year-Round'::text\"\n        },\n        {\n            \"data_type\": \"timestamp with time zone\",\n            \"table_name\": \"sports\",\n            \"column_name\": \"created_at\",\n            \"is_nullable\": \"NO\",\n            \"column_default\": \"now()\"\n        },\n        {\n            \"data_type\": \"text\",\n            \"table_name\": \"sports\",\n            \"column_name\": \"base_sport\",\n            \"is_nullable\": \"NO\",\n            \"column_default\": \"''::text\"\n        },\n        {\n            \"data_type\": \"uuid\",\n            \"table_name\": \"team_invites\",\n            \"column_name\": \"id\",\n            \"is_nullable\": \"NO\",\n            \"column_default\": \"gen_random_uuid()\"\n        },\n        {\n            \"data_type\": \"uuid\",\n            \"table_name\": \"team_invites\",\n            \"column_name\": \"team_id\",\n            \"is_nullable\": \"NO\",\n            \"column_default\": null\n        },\n        {\n            \"data_type\": \"text\",\n            \"table_name\": \"team_invites\",\n            \"column_name\": \"code\",\n            \"is_nullable\": \"NO\",\n            \"column_default\": null\n        },\n        {\n            \"data_type\": \"uuid\",\n            \"table_name\": \"team_invites\",\n            \"column_name\": \"created_by\",\n            \"is_nullable\": \"YES\",\n            \"column_default\": null\n        },\n        {\n            \"data_type\": \"timestamp with time zone\",\n            \"table_name\": \"team_invites\",\n            \"column_name\": \"created_at\",\n            \"is_nullable\": \"NO\",\n            \"column_default\": \"now()\"\n        },\n        {\n            \"data_type\": \"timestamp with time zone\",\n            \"table_name\": \"team_invites\",\n            \"column_name\": \"expires_at\",\n            \"is_nullable\": \"NO\",\n            \"column_default\": null\n        },\n        {\n            \"data_type\": \"boolean\",\n            \"table_name\": \"team_invites\",\n            \"column_name\": \"is_active\",\n            \"is_nullable\": \"NO\",\n            \"column_default\": \"true\"\n        },\n        {\n            \"data_type\": \"uuid\",\n            \"table_name\": \"team_members\",\n            \"column_name\": \"id\",\n            \"is_nullable\": \"NO\",\n            \"column_default\": \"uuid_generate_v4()\"\n        },\n        {\n            \"data_type\": \"uuid\",\n            \"table_name\": \"team_members\",\n            \"column_name\": \"team_id\",\n            \"is_nullable\": \"NO\",\n            \"column_default\": null\n        },\n        {\n            \"data_type\": \"uuid\",\n            \"table_name\": \"team_members\",\n            \"column_name\": \"user_id\",\n            \"is_nullable\": \"NO\",\n            \"column_default\": null\n        },\n        {\n            \"data_type\": \"text\",\n            \"table_name\": \"team_members\",\n            \"column_name\": \"role\",\n            \"is_nullable\": \"NO\",\n            \"column_default\": \"'player'::text\"\n        },\n        {\n            \"data_type\": \"uuid\",\n            \"table_name\": \"team_members\",\n            \"column_name\": \"player_id\",\n            \"is_nullable\": \"YES\",\n            \"column_default\": null\n        },\n        {\n            \"data_type\": \"timestamp with time zone\",\n            \"table_name\": \"team_members\",\n            \"column_name\": \"created_at\",\n            \"is_nullable\": \"NO\",\n            \"column_default\": \"now()\"\n        },\n        {\n            \"data_type\": \"uuid\",\n            \"table_name\": \"teams\",\n            \"column_name\": \"id\",\n            \"is_nullable\": \"NO\",\n            \"column_default\": \"uuid_generate_v4()\"\n        },\n        {\n            \"data_type\": \"text\",\n            \"table_name\": \"teams\",\n            \"column_name\": \"team_name\",\n            \"is_nullable\": \"NO\",\n            \"column_default\": null\n        },\n        {\n            \"data_type\": \"text\",\n            \"table_name\": \"teams\",\n            \"column_name\": \"sport\",\n            \"is_nullable\": \"NO\",\n            \"column_default\": \"'General'::text\"\n        },\n        {\n            \"data_type\": \"uuid\",\n            \"table_name\": \"teams\",\n            \"column_name\": \"sport_id\",\n            \"is_nullable\": \"YES\",\n            \"column_default\": null\n        },\n        {\n            \"data_type\": \"uuid\",\n            \"table_name\": \"teams\",\n            \"column_name\": \"created_by\",\n            \"is_nullable\": \"YES\",\n            \"column_default\": null\n        },\n        {\n            \"data_type\": \"timestamp with time zone\",\n            \"table_name\": \"teams\",\n            \"column_name\": \"created_at\",\n            \"is_nullable\": \"NO\",\n            \"column_default\": \"now()\"\n        },\n        {\n            \"data_type\": \"uuid\",\n            \"table_name\": \"users\",\n            \"column_name\": \"id\",\n            \"is_nullable\": \"NO\",\n            \"column_default\": \"uuid_generate_v4()\"\n        },\n        {\n            \"data_type\": \"uuid\",\n            \"table_name\": \"users\",\n            \"column_name\": \"user_id\",\n            \"is_nullable\": \"NO\",\n            \"column_default\": null\n        },\n        {\n            \"data_type\": \"text\",\n            \"table_name\": \"users\",\n            \"column_name\": \"first_name\",\n            \"is_nullable\": \"NO\",\n            \"column_default\": \"''::text\"\n        },\n        {\n            \"data_type\": \"text\",\n            \"table_name\": \"users\",\n            \"column_name\": \"last_name\",\n            \"is_nullable\": \"NO\",\n            \"column_default\": \"''::text\"\n        },\n        {\n            \"data_type\": \"text\",\n            \"table_name\": \"users\",\n            \"column_name\": \"name\",\n            \"is_nullable\": \"YES\",\n            \"column_default\": null\n        },\n        {\n            \"data_type\": \"text\",\n            \"table_name\": \"users\",\n            \"column_name\": \"nickname\",\n            \"is_nullable\": \"YES\",\n            \"column_default\": null\n        },\n        {\n            \"data_type\": \"text\",\n            \"table_name\": \"users\",\n            \"column_name\": \"athlete_id\",\n            \"is_nullable\": \"YES\",\n            \"column_default\": null\n        },\n        {\n            \"data_type\": \"text\",\n            \"table_name\": \"users\",\n            \"column_name\": \"email\",\n            \"is_nullable\": \"NO\",\n            \"column_default\": null\n        },\n        {\n            \"data_type\": \"text\",\n            \"table_name\": \"users\",\n            \"column_name\": \"organization\",\n            \"is_nullable\": \"YES\",\n            \"column_default\": null\n        },\n        {\n            \"data_type\": \"timestamp with time zone\",\n            \"table_name\": \"users\",\n            \"column_name\": \"created_at\",\n            \"is_nullable\": \"NO\",\n            \"column_default\": \"now()\"\n        },\n        {\n            \"data_type\": \"uuid\",\n            \"table_name\": \"v_owner_user_id\",\n            \"column_name\": \"id\",\n            \"is_nullable\": \"YES\",\n            \"column_default\": null\n        },\n        {\n            \"data_type\": \"uuid\",\n            \"table_name\": \"v_stuck_registrations\",\n            \"column_name\": \"auth_user_id\",\n            \"is_nullable\": \"YES\",\n            \"column_default\": null\n        },\n        {\n            \"data_type\": \"character varying\",\n            \"table_name\": \"v_stuck_registrations\",\n            \"column_name\": \"email\",\n            \"is_nullable\": \"YES\",\n            \"column_default\": null\n        },\n        {\n            \"data_type\": \"timestamp with time zone\",\n            \"table_name\": \"v_stuck_registrations\",\n            \"column_name\": \"auth_created_at\",\n            \"is_nullable\": \"YES\",\n            \"column_default\": null\n        },\n        {\n            \"data_type\": \"timestamp with time zone\",\n            \"table_name\": \"v_stuck_registrations\",\n            \"column_name\": \"email_confirmed_at\",\n            \"is_nullable\": \"YES\",\n            \"column_default\": null\n        }\n    ],\n    \"functions\": [\n        {\n            \"arguments\": \"\",\n            \"definition\": \"CREATE OR REPLACE FUNCTION private.get_my_team_ids()\\n RETURNS SETOF uuid\\n LANGUAGE sql\\n STABLE SECURITY DEFINER\\n SET search_path TO 'public'\\nAS $function$\\r\\n  -- Returns every team_id where the calling user is a member.\\r\\n  -- private.get_my_user_id() is an existing SECURITY DEFINER helper that\\r\\n  -- resolves auth.uid() → public.users.id.\\r\\n  SELECT team_id\\r\\n  FROM   public.team_members\\r\\n  WHERE  user_id = private.get_my_user_id();\\r\\n$function$\\n\",\n            \"return_type\": \"SETOF uuid\",\n            \"schema_name\": \"private\",\n            \"function_name\": \"get_my_team_ids\",\n            \"security_type\": \"Security Definer\"\n        },\n        {\n            \"arguments\": \"\",\n            \"definition\": \"CREATE OR REPLACE FUNCTION private.get_my_user_id()\\n RETURNS uuid\\n LANGUAGE sql\\n STABLE SECURITY DEFINER\\n SET search_path TO 'public'\\nAS $function$\\r\\n  SELECT id FROM public.users WHERE user_id = auth.uid() LIMIT 1;\\r\\n$function$\\n\",\n            \"return_type\": \"uuid\",\n            \"schema_name\": \"private\",\n            \"function_name\": \"get_my_user_id\",\n            \"security_type\": \"Security Definer\"\n        },\n        {\n            \"arguments\": \"p_team_id uuid, p_email text, p_role text\",\n            \"definition\": \"CREATE OR REPLACE FUNCTION public.add_member_to_team(p_team_id uuid, p_email text, p_role text)\\n RETURNS void\\n LANGUAGE plpgsql\\n SECURITY DEFINER\\n SET search_path TO 'public'\\nAS $function$\\r\\nDECLARE\\r\\n  v_user_id UUID;\\r\\nBEGIN\\r\\n  -- Resolve user by email from public.users (populated by handle_new_user trigger)\\r\\n  SELECT id INTO v_user_id\\r\\n  FROM public.users\\r\\n  WHERE email = LOWER(TRIM(p_email))\\r\\n  LIMIT 1;\\r\\n\\r\\n  IF v_user_id IS NULL THEN\\r\\n    RAISE EXCEPTION 'No Apex On Deck account found for email: %', p_email;\\r\\n  END IF;\\r\\n\\r\\n  -- Verify the caller is an owner/coach/manager of this team\\r\\n  IF NOT EXISTS (\\r\\n    SELECT 1 FROM public.team_members\\r\\n    WHERE team_id = p_team_id\\r\\n      AND user_id = auth.uid()\\r\\n      AND role IN ('owner', 'coach', 'team_manager')\\r\\n  ) THEN\\r\\n    RAISE EXCEPTION 'You are not authorized to add members to this team';\\r\\n  END IF;\\r\\n\\r\\n  -- Validate role\\r\\n  IF p_role NOT IN ('coach', 'player', 'team_parent', 'team_manager') THEN\\r\\n    RAISE EXCEPTION 'Invalid role: %', p_role;\\r\\n  END IF;\\r\\n\\r\\n  -- Insert or update team membership\\r\\n  INSERT INTO public.team_members (team_id, user_id, role)\\r\\n  VALUES (p_team_id, v_user_id, p_role)\\r\\n  ON CONFLICT (team_id, user_id)\\r\\n  DO UPDATE SET role = EXCLUDED.role;\\r\\nEND;\\r\\n$function$\\n\",\n            \"return_type\": \"void\",\n            \"schema_name\": \"public\",\n            \"function_name\": \"add_member_to_team\",\n            \"security_type\": \"Security Definer\"\n        },\n        {\n            \"arguments\": \"\",\n            \"definition\": \"CREATE OR REPLACE FUNCTION public.auto_link_player_v1_5()\\n RETURNS trigger\\n LANGUAGE plpgsql\\n SECURITY DEFINER\\nAS $function$\\r\\nDECLARE\\r\\n    v_user_id uuid;\\r\\nBEGIN\\r\\n    -- Only try to link if an email is provided and no user_id is set yet\\r\\n    IF NEW.student_email IS NOT NULL AND NEW.user_id IS NULL THEN\\r\\n        -- Look for a user with this email\\r\\n        SELECT id INTO v_user_id FROM public.users \\r\\n        WHERE lower(email) = lower(trim(NEW.student_email)) LIMIT 1;\\r\\n\\r\\n        IF v_user_id IS NOT NULL THEN\\r\\n            NEW.user_id := v_user_id;\\r\\n            \\r\\n            -- Also add them to team_members automatically\\r\\n            INSERT INTO public.team_members (team_id, user_id, role, player_id)\\r\\n            VALUES (NEW.team_id, v_user_id, 'player', NEW.id)\\r\\n            ON CONFLICT (team_id, user_id) DO UPDATE \\r\\n            SET role = 'player', player_id = EXCLUDED.player_id;\\r\\n        END IF;\\r\\n    END IF;\\r\\n    RETURN NEW;\\r\\nEND;\\r\\n$function$\\n\",\n            \"return_type\": \"trigger\",\n            \"schema_name\": \"public\",\n            \"function_name\": \"auto_link_player_v1_5\",\n            \"security_type\": \"Security Definer\"\n        },\n        {\n            \"arguments\": \"p_old_email text, p_new_email text\",\n            \"definition\": \"CREATE OR REPLACE FUNCTION public.change_user_email(p_old_email text, p_new_email text)\\n RETURNS void\\n LANGUAGE plpgsql\\n SECURITY DEFINER\\n SET search_path TO 'public'\\nAS $function$\\r\\nDECLARE\\r\\n  v_user_id    uuid;   -- public.users.id of the account being changed\\r\\n  v_auth_uid   uuid;   -- auth.uid() of the calling session\\r\\n  v_existing   uuid;   -- used to check if new email is already taken\\r\\nBEGIN\\r\\n  -- ── Resolve the calling user's auth UID ──────────────────────────────────\\r\\n  v_auth_uid := auth.uid();\\r\\n  IF v_auth_uid IS NULL THEN\\r\\n    RAISE EXCEPTION 'Not authenticated.' USING ERRCODE = '28000';\\r\\n  END IF;\\r\\n\\r\\n  -- ── Normalise inputs ──────────────────────────────────────────────────────\\r\\n  p_old_email := lower(trim(p_old_email));\\r\\n  p_new_email := lower(trim(p_new_email));\\r\\n\\r\\n  IF p_old_email = p_new_email THEN\\r\\n    RAISE EXCEPTION 'New email is the same as the current email.'\\r\\n      USING ERRCODE = '22023';\\r\\n  END IF;\\r\\n\\r\\n  -- ── Verify the caller owns the row with p_old_email ──────────────────────\\r\\n  -- This prevents a user from changing another user's email even if they\\r\\n  -- somehow know the old email.\\r\\n  SELECT id INTO v_user_id\\r\\n  FROM public.users\\r\\n  WHERE email = p_old_email\\r\\n    AND user_id = v_auth_uid   -- must match the calling session\\r\\n  LIMIT 1;\\r\\n\\r\\n  IF v_user_id IS NULL THEN\\r\\n    RAISE EXCEPTION 'Current email does not match your account.'\\r\\n      USING ERRCODE = '28000';\\r\\n  END IF;\\r\\n\\r\\n  -- ── Check the new email is not already in use ─────────────────────────────\\r\\n  SELECT id INTO v_existing\\r\\n  FROM public.users\\r\\n  WHERE email = p_new_email\\r\\n  LIMIT 1;\\r\\n\\r\\n  IF v_existing IS NOT NULL THEN\\r\\n    RAISE EXCEPTION 'That email address is already in use by another account.'\\r\\n      USING ERRCODE = '23505';\\r\\n  END IF;\\r\\n\\r\\n  -- ── Cascade the email change across all relevant tables ───────────────────\\r\\n\\r\\n  -- 1. Update the user's own profile row.\\r\\n  UPDATE public.users\\r\\n  SET email = p_new_email\\r\\n  WHERE id = v_user_id;\\r\\n\\r\\n  -- 2. Update any player rows where athlete_email matches the old email.\\r\\n  --    This keeps the athlete email in sync when the athlete changes their\\r\\n  --    own account email.\\r\\n  UPDATE public.players\\r\\n  SET athlete_email = p_new_email\\r\\n  WHERE athlete_email = p_old_email;\\r\\n\\r\\n  -- 3. Update any player rows where guardian_email matches the old email.\\r\\n  --    This keeps guardian links in sync when a guardian changes their email.\\r\\n  UPDATE public.players\\r\\n  SET guardian_email = p_new_email\\r\\n  WHERE guardian_email = p_old_email;\\r\\n\\r\\n  -- Note: The Supabase Auth email is updated separately by the Flutter client\\r\\n  -- via supabase.auth.updateUser() AFTER this RPC succeeds, to trigger the\\r\\n  -- email verification flow.  This function only handles the public schema.\\r\\nEND;\\r\\n$function$\\n\",\n            \"return_type\": \"void\",\n            \"schema_name\": \"public\",\n            \"function_name\": \"change_user_email\",\n            \"security_type\": \"Security Definer\"\n        },\n        {\n            \"arguments\": \"p_team_name text, p_sport text DEFAULT 'General'::text, p_sport_id uuid DEFAULT NULL::uuid\",\n            \"definition\": \"CREATE OR REPLACE FUNCTION public.create_team(p_team_name text, p_sport text DEFAULT 'General'::text, p_sport_id uuid DEFAULT NULL::uuid)\\n RETURNS uuid\\n LANGUAGE plpgsql\\n SECURITY DEFINER\\n SET search_path TO 'public'\\nAS $function$\\r\\nDECLARE v_user_id uuid; v_team_id uuid;\\r\\nBEGIN\\r\\n  v_user_id := private.get_my_user_id();\\r\\n  INSERT INTO public.teams (team_name, sport, sport_id, created_by)\\r\\n  VALUES (p_team_name, p_sport, p_sport_id, v_user_id) RETURNING id INTO v_team_id;\\r\\n  INSERT INTO public.team_members (team_id, user_id, role) VALUES (v_team_id, v_user_id, 'owner');\\r\\n  RETURN v_team_id;\\r\\nEND;\\r\\n$function$\\n\",\n            \"return_type\": \"uuid\",\n            \"schema_name\": \"public\",\n            \"function_name\": \"create_team\",\n            \"security_type\": \"Security Definer\"\n        },\n        {\n            \"arguments\": \"\",\n            \"definition\": \"CREATE OR REPLACE FUNCTION public.create_team_membership_v1_5()\\n RETURNS trigger\\n LANGUAGE plpgsql\\n SECURITY DEFINER\\nAS $function$\\r\\nBEGIN\\r\\n    IF NEW.user_id IS NOT NULL THEN\\r\\n        INSERT INTO public.team_members (team_id, user_id, role, player_id)\\r\\n        VALUES (NEW.team_id, NEW.user_id, 'player', NEW.id)\\r\\n        ON CONFLICT (team_id, user_id) DO UPDATE \\r\\n        SET player_id = EXCLUDED.player_id, role = 'player';\\r\\n    END IF;\\r\\n    RETURN NEW;\\r\\nEND;\\r\\n$function$\\n\",\n            \"return_type\": \"trigger\",\n            \"schema_name\": \"public\",\n            \"function_name\": \"create_team_membership_v1_5\",\n            \"security_type\": \"Security Definer\"\n        },\n        {\n            \"arguments\": \"\",\n            \"definition\": \"CREATE OR REPLACE FUNCTION public.fn_auto_link_players_on_signup()\\n RETURNS trigger\\n LANGUAGE plpgsql\\n SECURITY DEFINER\\n SET search_path TO 'public'\\nAS $function$\\r\\nBEGIN\\r\\n  -- For every player record whose athlete_email matches the new user's email\\r\\n  -- and that isn't linked yet, set user_id and upsert a team_members row.\\r\\n  UPDATE public.players\\r\\n  SET user_id = NEW.id\\r\\n  WHERE LOWER(TRIM(athlete_email)) = LOWER(TRIM(NEW.email))\\r\\n    AND user_id IS NULL;\\r\\n\\r\\n  -- The existing trigger fn_sync_player_membership_on_link fires on each\\r\\n  -- players.user_id update and upserts the team_members row automatically,\\r\\n  -- so no explicit team_members INSERT is needed here.\\r\\n\\r\\n  RETURN NEW;\\r\\nEND;\\r\\n$function$\\n\",\n            \"return_type\": \"trigger\",\n            \"schema_name\": \"public\",\n            \"function_name\": \"fn_auto_link_players_on_signup\",\n            \"security_type\": \"Security Definer\"\n        },\n        {\n            \"arguments\": \"\",\n            \"definition\": \"CREATE OR REPLACE FUNCTION public.fn_create_team_membership()\\n RETURNS trigger\\n LANGUAGE plpgsql\\n SECURITY DEFINER\\nAS $function$\\r\\nBEGIN\\r\\n    -- Only link if we successfully found a user_id in Step 1\\r\\n    IF NEW.user_id IS NOT NULL THEN\\r\\n        INSERT INTO public.team_members (team_id, user_id, role, player_id)\\r\\n        VALUES (NEW.team_id, NEW.user_id, 'player', NEW.id)\\r\\n        ON CONFLICT (team_id, user_id) DO UPDATE \\r\\n        SET player_id = EXCLUDED.player_id, role = 'player';\\r\\n    END IF;\\r\\n    RETURN NEW;\\r\\nEND;\\r\\n$function$\\n\",\n            \"return_type\": \"trigger\",\n            \"schema_name\": \"public\",\n            \"function_name\": \"fn_create_team_membership\",\n            \"security_type\": \"Security Definer\"\n        },\n        {\n            \"arguments\": \"\",\n            \"definition\": \"CREATE OR REPLACE FUNCTION public.fn_link_new_user_to_existing_player()\\n RETURNS trigger\\n LANGUAGE plpgsql\\n SECURITY DEFINER\\n SET search_path TO 'public'\\nAS $function$\\r\\nDECLARE\\r\\n    found_player_id UUID;\\r\\nBEGIN\\r\\n    -- 1. Find if a player exists with this email\\r\\n    SELECT id INTO found_player_id \\r\\n    FROM public.players \\r\\n    WHERE lower(trim(student_email)) = lower(trim(NEW.email))\\r\\n    LIMIT 1;\\r\\n\\r\\n    -- 2. If found, try to link them\\r\\n    IF found_player_id IS NOT NULL THEN\\r\\n        BEGIN\\r\\n            -- Attempt the link\\r\\n            UPDATE public.players \\r\\n            SET user_id = NEW.user_id \\r\\n            WHERE id = found_player_id;\\r\\n\\r\\n            -- Attempt the membership\\r\\n            INSERT INTO public.team_members (team_id, user_id, role, player_id)\\r\\n            SELECT team_id, NEW.user_id, 'player', id\\r\\n            FROM public.players\\r\\n            WHERE id = found_player_id\\r\\n            ON CONFLICT (team_id, user_id) DO NOTHING;\\r\\n            \\r\\n        EXCEPTION WHEN foreign_key_violation THEN\\r\\n            -- [Inference] If the DB says \\\"User ID not found\\\" (Race Condition),\\r\\n            -- we log it and let the signup finish. We can run our audit to catch these.\\r\\n            RAISE NOTICE 'Caught FK violation for user %, skipping auto-link', NEW.user_id;\\r\\n        END;\\r\\n    END IF;\\r\\n\\r\\n    RETURN NEW;\\r\\nEND;\\r\\n$function$\\n\",\n            \"return_type\": \"trigger\",\n            \"schema_name\": \"public\",\n            \"function_name\": \"fn_link_new_user_to_existing_player\",\n            \"security_type\": \"Security Definer\"\n        },\n        {\n            \"arguments\": \"\",\n            \"definition\": \"CREATE OR REPLACE FUNCTION public.fn_set_player_user_id()\\n RETURNS trigger\\n LANGUAGE plpgsql\\n SECURITY DEFINER\\nAS $function$\\r\\nBEGIN\\r\\n    SELECT id INTO NEW.user_id \\r\\n    FROM public.users \\r\\n    WHERE lower(email) = lower(trim(NEW.student_email)) \\r\\n    LIMIT 1;\\r\\n    RETURN NEW;\\r\\nEND;\\r\\n$function$\\n\",\n            \"return_type\": \"trigger\",\n            \"schema_name\": \"public\",\n            \"function_name\": \"fn_set_player_user_id\",\n            \"security_type\": \"Security Definer\"\n        },\n        {\n            \"arguments\": \"\",\n            \"definition\": \"CREATE OR REPLACE FUNCTION public.fn_sync_player_membership_on_link()\\n RETURNS trigger\\n LANGUAGE plpgsql\\n SECURITY DEFINER\\n SET search_path TO 'public'\\nAS $function$\\r\\nBEGIN\\r\\n  -- Only act when user_id transitions from NULL to a non-NULL value.\\r\\n  -- This prevents the trigger from firing on routine player UPDATE calls\\r\\n  -- (e.g., status changes, name edits) that don't touch user_id.\\r\\n  IF OLD.user_id IS NULL AND NEW.user_id IS NOT NULL THEN\\r\\n\\r\\n    -- Upsert a team_members row so the newly-linked user can see the team.\\r\\n    --\\r\\n    -- ON CONFLICT: if a row already exists for this (team_id, user_id) pair\\r\\n    -- (e.g., manually added as a coach before being linked as a player),\\r\\n    -- preserve the existing role rather than downgrading it to 'player'.\\r\\n    -- Only update player_id if it is not yet set.\\r\\n    INSERT INTO public.team_members (team_id, user_id, role, player_id)\\r\\n    VALUES (NEW.team_id, NEW.user_id, 'player', NEW.id)\\r\\n    ON CONFLICT (team_id, user_id)\\r\\n    DO UPDATE SET\\r\\n      player_id = EXCLUDED.player_id\\r\\n      -- NOTE: role is intentionally NOT updated here so that a user who is\\r\\n      -- already a 'coach' or 'owner' on the team does not get demoted to\\r\\n      -- 'player' just because a player row was linked to their account.\\r\\n      -- If the existing role needs changing, use the \\\"Change Role\\\" dialog\\r\\n      -- in ManageMembersScreen.\\r\\n    ;\\r\\n\\r\\n  END IF;\\r\\n\\r\\n  -- Return NEW so the original UPDATE proceeds normally.\\r\\n  RETURN NEW;\\r\\nEND;\\r\\n$function$\\n\",\n            \"return_type\": \"trigger\",\n            \"schema_name\": \"public\",\n            \"function_name\": \"fn_sync_player_membership_on_link\",\n            \"security_type\": \"Security Definer\"\n        },\n        {\n            \"arguments\": \"\",\n            \"definition\": \"CREATE OR REPLACE FUNCTION public.get_current_user_id()\\n RETURNS uuid\\n LANGUAGE sql\\n STABLE SECURITY DEFINER\\n SET search_path TO 'public'\\nAS $function$\\r\\n    SELECT id FROM public.users WHERE user_id = auth.uid() LIMIT 1;\\r\\n$function$\\n\",\n            \"return_type\": \"uuid\",\n            \"schema_name\": \"public\",\n            \"function_name\": \"get_current_user_id\",\n            \"security_type\": \"Security Definer\"\n        },\n        {\n            \"arguments\": \"p_team_id uuid\",\n            \"definition\": \"CREATE OR REPLACE FUNCTION public.get_or_create_team_invite(p_team_id uuid)\\n RETURNS TABLE(code text, expires_at timestamp with time zone)\\n LANGUAGE plpgsql\\n SECURITY DEFINER\\n SET search_path TO 'public'\\nAS $function$\\r\\nDECLARE\\r\\n  v_caller_id uuid;\\r\\n  v_code      text;\\r\\n  v_expires   timestamptz;\\r\\nBEGIN\\r\\n  -- Resolve caller.\\r\\n  SELECT id INTO v_caller_id FROM public.users WHERE user_id = auth.uid();\\r\\n  IF v_caller_id IS NULL THEN\\r\\n    RAISE EXCEPTION 'Not authenticated.';\\r\\n  END IF;\\r\\n\\r\\n  -- Verify manager role.\\r\\n  IF NOT EXISTS (\\r\\n    SELECT 1 FROM public.team_members\\r\\n    WHERE team_id = p_team_id\\r\\n      AND user_id = v_caller_id\\r\\n      AND role    IN ('owner', 'coach', 'team_manager')\\r\\n  ) THEN\\r\\n    RAISE EXCEPTION 'Only managers may create team invites.';\\r\\n  END IF;\\r\\n\\r\\n  -- Return existing active, unexpired invite if present.\\r\\n  SELECT ti.code, ti.expires_at\\r\\n  INTO   v_code, v_expires\\r\\n  FROM   public.team_invites ti\\r\\n  WHERE  ti.team_id  = p_team_id\\r\\n    AND  ti.is_active = true\\r\\n    AND  ti.expires_at > now();\\r\\n\\r\\n  IF v_code IS NOT NULL THEN\\r\\n    RETURN QUERY SELECT v_code, v_expires;\\r\\n    RETURN;\\r\\n  END IF;\\r\\n\\r\\n  -- Deactivate any stale active invites (expired but flag not yet cleared).\\r\\n  UPDATE public.team_invites\\r\\n  SET    is_active = false\\r\\n  WHERE  team_id   = p_team_id\\r\\n    AND  is_active = true;\\r\\n\\r\\n  -- Generate a new 6-character alphanumeric code (uppercase).\\r\\n  v_code    := upper(substring(replace(gen_random_uuid()::text, '-', ''), 1, 6));\\r\\n  v_expires := now() + interval '24 hours';\\r\\n\\r\\n  INSERT INTO public.team_invites (team_id, code, created_by, expires_at)\\r\\n  VALUES (p_team_id, v_code, v_caller_id, v_expires);\\r\\n\\r\\n  RETURN QUERY SELECT v_code, v_expires;\\r\\nEND;\\r\\n$function$\\n\",\n            \"return_type\": \"TABLE(code text, expires_at timestamp with time zone)\",\n            \"schema_name\": \"public\",\n            \"function_name\": \"get_or_create_team_invite\",\n            \"security_type\": \"Security Definer\"\n        },\n        {\n            \"arguments\": \"p_team_id uuid\",\n            \"definition\": \"CREATE OR REPLACE FUNCTION public.get_team_role(p_team_id uuid)\\n RETURNS text\\n LANGUAGE sql\\n STABLE SECURITY DEFINER\\n SET search_path TO 'public'\\nAS $function$\\r\\n    SELECT role FROM public.team_members WHERE team_id = p_team_id AND user_id = public.get_current_user_id() LIMIT 1;\\r\\n$function$\\n\",\n            \"return_type\": \"text\",\n            \"schema_name\": \"public\",\n            \"function_name\": \"get_team_role\",\n            \"security_type\": \"Security Definer\"\n        },\n        {\n            \"arguments\": \"\",\n            \"definition\": \"CREATE OR REPLACE FUNCTION public.handle_new_user()\\n RETURNS trigger\\n LANGUAGE plpgsql\\n SECURITY DEFINER\\nAS $function$\\r\\nBEGIN\\r\\n  INSERT INTO public.users (id, user_id, email, first_name, last_name)\\r\\n  VALUES (\\r\\n    NEW.id, \\r\\n    NEW.id, \\r\\n    NEW.email, \\r\\n    COALESCE(NEW.raw_user_meta_data->>'first_name', ''), \\r\\n    COALESCE(NEW.raw_user_meta_data->>'last_name', '')\\r\\n  )\\r\\n  -- This is the critical fix:\\r\\n  ON CONFLICT (id) DO UPDATE \\r\\n  SET \\r\\n    user_id = EXCLUDED.id,\\r\\n    email = EXCLUDED.email,\\r\\n    first_name = COALESCE(EXCLUDED.first_name, public.users.first_name),\\r\\n    last_name = COALESCE(EXCLUDED.last_name, public.users.last_name);\\r\\n    \\r\\n  RETURN NEW;\\r\\nEND;\\r\\n$function$\\n\",\n            \"return_type\": \"trigger\",\n            \"schema_name\": \"public\",\n            \"function_name\": \"handle_new_user\",\n            \"security_type\": \"Security Definer\"\n        },\n        {\n            \"arguments\": \"p_team_id uuid\",\n            \"definition\": \"CREATE OR REPLACE FUNCTION public.is_team_member(p_team_id uuid)\\n RETURNS boolean\\n LANGUAGE sql\\n STABLE SECURITY DEFINER\\n SET search_path TO 'public'\\nAS $function$\\r\\n    SELECT EXISTS (SELECT 1 FROM public.team_members WHERE team_id = p_team_id AND user_id = public.get_current_user_id());\\r\\n$function$\\n\",\n            \"return_type\": \"boolean\",\n            \"schema_name\": \"public\",\n            \"function_name\": \"is_team_member\",\n            \"security_type\": \"Security Definer\"\n        },\n        {\n            \"arguments\": \"p_team_id uuid\",\n            \"definition\": \"CREATE OR REPLACE FUNCTION public.is_team_owner(p_team_id uuid)\\n RETURNS boolean\\n LANGUAGE sql\\n STABLE SECURITY DEFINER\\n SET search_path TO 'public'\\nAS $function$\\r\\n    SELECT public.get_team_role(p_team_id) = 'owner';\\r\\n$function$\\n\",\n            \"return_type\": \"boolean\",\n            \"schema_name\": \"public\",\n            \"function_name\": \"is_team_owner\",\n            \"security_type\": \"Security Definer\"\n        },\n        {\n            \"arguments\": \"p_team_id uuid, p_player_id uuid, p_player_email text\",\n            \"definition\": \"CREATE OR REPLACE FUNCTION public.link_player_to_user(p_team_id uuid, p_player_id uuid, p_player_email text)\\n RETURNS void\\n LANGUAGE plpgsql\\n SECURITY DEFINER\\n SET search_path TO 'public'\\nAS $function$\\r\\nDECLARE\\r\\n  v_user_id UUID;\\r\\nBEGIN\\r\\n  -- Resolve user by email\\r\\n  SELECT id INTO v_user_id\\r\\n  FROM public.users\\r\\n  WHERE email = p_player_email\\r\\n  LIMIT 1;\\r\\n\\r\\n  IF v_user_id IS NULL THEN\\r\\n    RAISE EXCEPTION 'No user found with email %', p_player_email;\\r\\n  END IF;\\r\\n\\r\\n  -- Verify the caller is an owner/coach/manager of this team\\r\\n  IF NOT EXISTS (\\r\\n    SELECT 1 FROM public.team_members\\r\\n    WHERE team_id = p_team_id\\r\\n      AND user_id = auth.uid()\\r\\n      AND role IN ('owner', 'coach', 'team_manager')\\r\\n  ) THEN\\r\\n    RAISE EXCEPTION 'Caller is not authorized to link players on this team';\\r\\n  END IF;\\r\\n\\r\\n  -- Link the player record to the resolved user\\r\\n  UPDATE public.players\\r\\n  SET user_id = v_user_id\\r\\n  WHERE id = p_player_id\\r\\n    AND team_id = p_team_id;\\r\\n\\r\\n  IF NOT FOUND THEN\\r\\n    RAISE EXCEPTION 'Player % not found on team %', p_player_id, p_team_id;\\r\\n  END IF;\\r\\n\\r\\n  -- Upsert team_members so the linked user can access the team\\r\\n  INSERT INTO public.team_members (team_id, user_id, role, player_id)\\r\\n  VALUES (p_team_id, v_user_id, 'player', p_player_id)\\r\\n  ON CONFLICT (team_id, user_id)\\r\\n  DO UPDATE SET\\r\\n    role      = EXCLUDED.role,\\r\\n    player_id = EXCLUDED.player_id;\\r\\nEND;\\r\\n$function$\\n\",\n            \"return_type\": \"void\",\n            \"schema_name\": \"public\",\n            \"function_name\": \"link_player_to_user\",\n            \"security_type\": \"Security Definer\"\n        },\n        {\n            \"arguments\": \"p_email text\",\n            \"definition\": \"CREATE OR REPLACE FUNCTION public.lookup_user_by_email(p_email text)\\n RETURNS TABLE(id uuid, user_id uuid, first_name text, last_name text, nickname text, athlete_id text, email text, organization text)\\n LANGUAGE sql\\n SECURITY DEFINER\\n SET search_path TO 'public'\\nAS $function$\\r\\n    SELECT\\r\\n        u.id,\\r\\n        u.user_id,\\r\\n        u.first_name,\\r\\n        u.last_name,\\r\\n        u.nickname,\\r\\n        u.athlete_id,\\r\\n        u.email,\\r\\n        u.organization\\r\\n    FROM public.users u\\r\\n    -- LOWER() on both sides for case-insensitive match.\\r\\n    -- This is safe against SQL injection because p_email is parameterised.\\r\\n    WHERE LOWER(u.email) = LOWER(p_email)\\r\\n    -- Limit 1 — emails are unique in public.users (mirrored from auth.users).\\r\\n    LIMIT 1;\\r\\n$function$\\n\",\n            \"return_type\": \"TABLE(id uuid, user_id uuid, first_name text, last_name text, nickname text, athlete_id text, email text, organization text)\",\n            \"schema_name\": \"public\",\n            \"function_name\": \"lookup_user_by_email\",\n            \"security_type\": \"Security Definer\"\n        },\n        {\n            \"arguments\": \"p_email text\",\n            \"definition\": \"CREATE OR REPLACE FUNCTION public.purge_unconfirmed_auth_user(p_email text)\\n RETURNS text\\n LANGUAGE plpgsql\\n SECURITY DEFINER\\n SET search_path TO 'public', 'auth'\\nAS $function$\\r\\nDECLARE\\r\\n  v_auth_id   UUID;\\r\\n  v_confirmed TIMESTAMPTZ;\\r\\nBEGIN\\r\\n  -- Locate the auth.users row for the given email.\\r\\n  SELECT id, email_confirmed_at\\r\\n  INTO   v_auth_id, v_confirmed\\r\\n  FROM   auth.users\\r\\n  WHERE  email = LOWER(TRIM(p_email))\\r\\n  LIMIT  1;\\r\\n\\r\\n  IF v_auth_id IS NULL THEN\\r\\n    RETURN 'NOT_FOUND: No auth.users row for ' || p_email;\\r\\n  END IF;\\r\\n\\r\\n  -- Safety guard: never purge a confirmed account.\\r\\n  IF v_confirmed IS NOT NULL THEN\\r\\n    RETURN 'REFUSED: auth.users row for ' || p_email || ' is already confirmed. '\\r\\n           || 'Use the normal account-deletion flow instead.';\\r\\n  END IF;\\r\\n\\r\\n  -- Remove the dangling public.users row first (FK reference).\\r\\n  DELETE FROM public.users WHERE user_id = v_auth_id;\\r\\n\\r\\n  -- Remove the unconfirmed auth.users row.\\r\\n  DELETE FROM auth.users WHERE id = v_auth_id;\\r\\n\\r\\n  RETURN 'PURGED: Removed unconfirmed auth record for ' || p_email\\r\\n         || '. The email can now be used to register a new account.';\\r\\nEND;\\r\\n$function$\\n\",\n            \"return_type\": \"text\",\n            \"schema_name\": \"public\",\n            \"function_name\": \"purge_unconfirmed_auth_user\",\n            \"security_type\": \"Security Definer\"\n        },\n        {\n            \"arguments\": \"p_code text\",\n            \"definition\": \"CREATE OR REPLACE FUNCTION public.redeem_team_invite(p_code text)\\n RETURNS TABLE(out_team_id uuid, out_team_name text, out_role text)\\n LANGUAGE plpgsql\\n SECURITY DEFINER\\n SET search_path TO 'public'\\nAS $function$\\r\\n  DECLARE\\r\\n    v_invite  team_invites%ROWTYPE;\\r\\n    v_user_id uuid := auth.uid();\\r\\n  BEGIN\\r\\n    SELECT *\\r\\n      INTO v_invite\\r\\n      FROM team_invites ti\\r\\n     WHERE ti.code = p_code\\r\\n       AND ti.is_active = true\\r\\n       AND ti.expires_at > now();\\r\\n\\r\\n    IF NOT FOUND THEN\\r\\n      RAISE EXCEPTION 'Invalid or expired invite code';\\r\\n    END IF;\\r\\n\\r\\n    INSERT INTO team_members (team_id, user_id, role)\\r\\n    VALUES (v_invite.team_id, v_user_id, 'player')\\r\\n    ON CONFLICT (team_id, user_id) DO NOTHING;\\r\\n\\r\\n    RETURN QUERY\\r\\n      SELECT t.id, t.team_name, tm.role\\r\\n        FROM teams t\\r\\n        JOIN team_members tm\\r\\n          ON tm.team_id = t.id\\r\\n         AND tm.user_id = v_user_id\\r\\n       WHERE t.id = v_invite.team_id;\\r\\n  END;\\r\\n  $function$\\n\",\n            \"return_type\": \"TABLE(out_team_id uuid, out_team_name text, out_role text)\",\n            \"schema_name\": \"public\",\n            \"function_name\": \"redeem_team_invite\",\n            \"security_type\": \"Security Definer\"\n        },\n        {\n            \"arguments\": \"p_team_id uuid\",\n            \"definition\": \"CREATE OR REPLACE FUNCTION public.revoke_team_invite(p_team_id uuid)\\n RETURNS void\\n LANGUAGE plpgsql\\n SECURITY DEFINER\\n SET search_path TO 'public'\\nAS $function$\\r\\nDECLARE\\r\\n  v_caller_id uuid;\\r\\nBEGIN\\r\\n  SELECT id INTO v_caller_id FROM public.users WHERE user_id = auth.uid();\\r\\n  IF v_caller_id IS NULL THEN\\r\\n    RAISE EXCEPTION 'Not authenticated.';\\r\\n  END IF;\\r\\n\\r\\n  IF NOT EXISTS (\\r\\n    SELECT 1 FROM public.team_members\\r\\n    WHERE team_id = p_team_id\\r\\n      AND user_id = v_caller_id\\r\\n      AND role    IN ('owner', 'coach', 'team_manager')\\r\\n  ) THEN\\r\\n    RAISE EXCEPTION 'Only managers may revoke team invites.';\\r\\n  END IF;\\r\\n\\r\\n  UPDATE public.team_invites\\r\\n  SET    is_active = false\\r\\n  WHERE  team_id   = p_team_id\\r\\n    AND  is_active = true;\\r\\nEND;\\r\\n$function$\\n\",\n            \"return_type\": \"void\",\n            \"schema_name\": \"public\",\n            \"function_name\": \"revoke_team_invite\",\n            \"security_type\": \"Security Definer\"\n        },\n        {\n            \"arguments\": \"\",\n            \"definition\": \"CREATE OR REPLACE FUNCTION public.set_player_user_id_v1_5()\\n RETURNS trigger\\n LANGUAGE plpgsql\\n SECURITY DEFINER\\nAS $function$\\r\\nBEGIN\\r\\n    SELECT id INTO NEW.user_id \\r\\n    FROM public.users \\r\\n    WHERE lower(email) = lower(trim(NEW.student_email)) \\r\\n    LIMIT 1;\\r\\n    RETURN NEW;\\r\\nEND;\\r\\n$function$\\n\",\n            \"return_type\": \"trigger\",\n            \"schema_name\": \"public\",\n            \"function_name\": \"set_player_user_id_v1_5\",\n            \"security_type\": \"Security Definer\"\n        },\n        {\n            \"arguments\": \"\",\n            \"definition\": \"CREATE OR REPLACE FUNCTION public.sync_player_to_user_v1_5()\\n RETURNS trigger\\n LANGUAGE plpgsql\\n SECURITY DEFINER\\nAS $function$\\r\\nDECLARE\\r\\n    found_user_id uuid;\\r\\nBEGIN\\r\\n    -- 1. Try to find a user with a matching email (case-insensitive)\\r\\n    SELECT id INTO found_user_id \\r\\n    FROM public.users \\r\\n    WHERE lower(email) = lower(trim(NEW.student_email)) \\r\\n    LIMIT 1;\\r\\n\\r\\n    -- 2. If we found someone, link them and update team_members\\r\\n    IF found_user_id IS NOT NULL THEN\\r\\n        NEW.user_id := found_user_id;\\r\\n        \\r\\n        -- Automatically ensure they are in the team_members table too\\r\\n        INSERT INTO public.team_members (team_id, user_id, role, player_id)\\r\\n        VALUES (NEW.team_id, found_user_id, 'player', NEW.id)\\r\\n        ON CONFLICT (team_id, user_id) DO UPDATE \\r\\n        SET player_id = EXCLUDED.player_id, role = 'player';\\r\\n    END IF;\\r\\n\\r\\n    RETURN NEW;\\r\\nEND;\\r\\n$function$\\n\",\n            \"return_type\": \"trigger\",\n            \"schema_name\": \"public\",\n            \"function_name\": \"sync_player_to_user_v1_5\",\n            \"security_type\": \"Security Definer\"\n        },\n        {\n            \"arguments\": \"\",\n            \"definition\": \"CREATE OR REPLACE FUNCTION public.sync_user_name()\\n RETURNS trigger\\n LANGUAGE plpgsql\\n SECURITY DEFINER\\n SET search_path TO 'public'\\nAS $function$\\r\\nBEGIN\\r\\n  NEW.name := trim(COALESCE(NEW.first_name, '') || ' ' || COALESCE(NEW.last_name, ''));\\r\\n  RETURN NEW;\\r\\nEND;\\r\\n$function$\\n\",\n            \"return_type\": \"trigger\",\n            \"schema_name\": \"public\",\n            \"function_name\": \"sync_user_name\",\n            \"security_type\": \"Security Definer\"\n        },\n        {\n            \"arguments\": \"p_team_id uuid, p_new_owner_user_id uuid\",\n            \"definition\": \"CREATE OR REPLACE FUNCTION public.transfer_ownership(p_team_id uuid, p_new_owner_user_id uuid)\\n RETURNS void\\n LANGUAGE plpgsql\\n SECURITY DEFINER\\n SET search_path TO 'public'\\nAS $function$\\r\\nDECLARE\\r\\n  v_caller_id uuid;\\r\\nBEGIN\\r\\n  -- Resolve the calling user's public.users.id.\\r\\n  SELECT id INTO v_caller_id\\r\\n  FROM public.users\\r\\n  WHERE user_id = auth.uid();\\r\\n\\r\\n  IF v_caller_id IS NULL THEN\\r\\n    RAISE EXCEPTION 'Not logged in.';\\r\\n  END IF;\\r\\n\\r\\n  -- Verify the caller is the current owner.\\r\\n  IF NOT EXISTS (\\r\\n    SELECT 1 FROM public.team_members\\r\\n    WHERE team_id = p_team_id\\r\\n      AND user_id = v_caller_id\\r\\n      AND role    = 'owner'\\r\\n  ) THEN\\r\\n    RAISE EXCEPTION 'Only the current owner can transfer ownership.';\\r\\n  END IF;\\r\\n\\r\\n  -- Verify the target is already a member of the team.\\r\\n  IF NOT EXISTS (\\r\\n    SELECT 1 FROM public.team_members\\r\\n    WHERE team_id = p_team_id\\r\\n      AND user_id = p_new_owner_user_id\\r\\n  ) THEN\\r\\n    RAISE EXCEPTION 'Target user is not a member of this team.';\\r\\n  END IF;\\r\\n\\r\\n  -- Both UPDATEs execute inside the same implicit transaction.\\r\\n  -- If either fails the entire operation rolls back.\\r\\n  UPDATE public.team_members\\r\\n  SET role = 'coach'\\r\\n  WHERE team_id = p_team_id\\r\\n    AND user_id = v_caller_id;\\r\\n\\r\\n  UPDATE public.team_members\\r\\n  SET role = 'owner'\\r\\n  WHERE team_id = p_team_id\\r\\n    AND user_id = p_new_owner_user_id;\\r\\nEND;\\r\\n$function$\\n\",\n            \"return_type\": \"void\",\n            \"schema_name\": \"public\",\n            \"function_name\": \"transfer_ownership\",\n            \"security_type\": \"Security Definer\"\n        }\n    ],\n    \"rls_status\": [\n        {\n            \"rls_forced\": false,\n            \"table_name\": \"game_rosters\",\n            \"rls_enabled\": true\n        },\n        {\n            \"rls_forced\": false,\n            \"table_name\": \"guardian_links\",\n            \"rls_enabled\": true\n        },\n        {\n            \"rls_forced\": false,\n            \"table_name\": \"players\",\n            \"rls_enabled\": true\n        },\n        {\n            \"rls_forced\": false,\n            \"table_name\": \"sports\",\n            \"rls_enabled\": true\n        },\n        {\n            \"rls_forced\": false,\n            \"table_name\": \"team_invites\",\n            \"rls_enabled\": true\n        },\n        {\n            \"rls_forced\": false,\n            \"table_name\": \"team_members\",\n            \"rls_enabled\": true\n        },\n        {\n            \"rls_forced\": false,\n            \"table_name\": \"teams\",\n            \"rls_enabled\": true\n        },\n        {\n            \"rls_forced\": false,\n            \"table_name\": \"users\",\n            \"rls_enabled\": true\n        },\n        {\n            \"rls_forced\": false,\n            \"table_name\": \"v_owner_user_id\",\n            \"rls_enabled\": false\n        }\n    ],\n    \"foreign_keys\": [\n        {\n            \"on_delete\": \"SET NULL\",\n            \"on_update\": \"NO ACTION\",\n            \"table_name\": \"game_rosters\",\n            \"column_name\": \"created_by\",\n            \"constraint_name\": \"game_rosters_created_by_fkey\",\n            \"foreign_table_name\": \"users\",\n            \"foreign_column_name\": \"id\"\n        },\n        {\n            \"on_delete\": \"CASCADE\",\n            \"on_update\": \"NO ACTION\",\n            \"table_name\": \"game_rosters\",\n            \"column_name\": \"team_id\",\n            \"constraint_name\": \"game_rosters_team_id_fkey\",\n            \"foreign_table_name\": \"teams\",\n            \"foreign_column_name\": \"id\"\n        },\n        {\n            \"on_delete\": \"CASCADE\",\n            \"on_update\": \"NO ACTION\",\n            \"table_name\": \"players\",\n            \"column_name\": \"team_id\",\n            \"constraint_name\": \"players_team_id_fkey\",\n            \"foreign_table_name\": \"teams\",\n            \"foreign_column_name\": \"id\"\n        },\n        {\n            \"on_delete\": \"SET NULL\",\n            \"on_update\": \"NO ACTION\",\n            \"table_name\": \"players\",\n            \"column_name\": \"user_id\",\n            \"constraint_name\": \"players_user_id_fkey\",\n            \"foreign_table_name\": \"users\",\n            \"foreign_column_name\": \"id\"\n        },\n        {\n            \"on_delete\": \"SET NULL\",\n            \"on_update\": \"NO ACTION\",\n            \"table_name\": \"team_invites\",\n            \"column_name\": \"created_by\",\n            \"constraint_name\": \"team_invites_created_by_fkey\",\n            \"foreign_table_name\": \"users\",\n            \"foreign_column_name\": \"id\"\n        },\n        {\n            \"on_delete\": \"CASCADE\",\n            \"on_update\": \"NO ACTION\",\n            \"table_name\": \"team_invites\",\n            \"column_name\": \"team_id\",\n            \"constraint_name\": \"team_invites_team_id_fkey\",\n            \"foreign_table_name\": \"teams\",\n            \"foreign_column_name\": \"id\"\n        },\n        {\n            \"on_delete\": \"SET NULL\",\n            \"on_update\": \"NO ACTION\",\n            \"table_name\": \"team_members\",\n            \"column_name\": \"player_id\",\n            \"constraint_name\": \"team_members_player_id_fkey\",\n            \"foreign_table_name\": \"players\",\n            \"foreign_column_name\": \"id\"\n        },\n        {\n            \"on_delete\": \"CASCADE\",\n            \"on_update\": \"NO ACTION\",\n            \"table_name\": \"team_members\",\n            \"column_name\": \"team_id\",\n            \"constraint_name\": \"team_members_team_id_fkey\",\n            \"foreign_table_name\": \"teams\",\n            \"foreign_column_name\": \"id\"\n        },\n        {\n            \"on_delete\": \"CASCADE\",\n            \"on_update\": \"NO ACTION\",\n            \"table_name\": \"team_members\",\n            \"column_name\": \"user_id\",\n            \"constraint_name\": \"team_members_user_id_fkey\",\n            \"foreign_table_name\": \"users\",\n            \"foreign_column_name\": \"id\"\n        },\n        {\n            \"on_delete\": \"SET NULL\",\n            \"on_update\": \"NO ACTION\",\n            \"table_name\": \"teams\",\n            \"column_name\": \"created_by\",\n            \"constraint_name\": \"teams_created_by_fkey\",\n            \"foreign_table_name\": \"users\",\n            \"foreign_column_name\": \"id\"\n        },\n        {\n            \"on_delete\": \"SET NULL\",\n            \"on_update\": \"NO ACTION\",\n            \"table_name\": \"teams\",\n            \"column_name\": \"sport_id\",\n            \"constraint_name\": \"teams_sport_id_fkey\",\n            \"foreign_table_name\": \"sports\",\n            \"foreign_column_name\": \"id\"\n        }\n    ]\n}"
  }
]